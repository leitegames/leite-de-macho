<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sirilo e o Leite de Macho</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-yellow: #ffde59;
            --secondary-yellow: #ffc300;
            --shadow-yellow: #c78f00;
            --text-dark: #3d2b00;
            
            /* Tema Padrão */
            --bg-dark: #141e30;
            --bg-light: #243b55;
            --ground: #27ae60;
            --border: #fff;
        }

        /* --- Estilos para Temas --- */
        .theme-day { --bg-dark: #4e7eff; --bg-light: #81c7ff; --ground: #2ecc71; --border: #fff; }
        .theme-hell { --bg-dark: #410a0a; --bg-light: #b91c1c; --ground: #93330b; --border: #ff8c00; }
        .theme-candy { --bg-dark: #f9a8d4; --bg-light: #f472b6; --ground: #ec4899; --border: #fff; }
        .theme-forest { --bg-dark: #064e3b; --bg-light: #059669; --ground: #84cc16; --border: #f0fdf4; }
        .theme-space { --bg-dark: #1e1b4b; --bg-light: #4f46e5; --ground: #6d28d9; --border: #a78bfa; }

        html, body {
            margin: 0; padding: 0; font-family: 'Fredoka One', cursive;
            width: 100%; height: 100%; overflow: hidden;
            background-color: #0c0c1e; display: flex;
            justify-content: center; align-items: center; touch-action: none;
        }

        #game-container {
            width: 100%; height: 100%;
            max-width: 500px; max-height: 100vh;
            background: linear-gradient(to bottom, var(--bg-dark), var(--bg-light));
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            position: relative; overflow: hidden;
            border: 5px solid var(--border);
            border-bottom: 10px solid var(--ground);
            border-radius: 20px;
            transition: background 0.5s, border 0.5s;
            display: flex; flex-direction: column;
        }
        
        #game-container.shake { animation: screen-shake 0.2s; }
        #game-canvas { width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* Interface (HUD) */
        #ui-container {
            position: absolute; top: 15px; left: 15px; right: 15px;
            display: flex; justify-content: space-between; align-items: center;
            gap: 10px; z-index: 10;
        }
        .hud-item {
            background: rgba(0, 0, 0, 0.25); padding: 8px 15px; border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3); display: flex;
            align-items: center; font-size: clamp(16px, 4vw, 24px);
            color: white; text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .hud-item.pulsate { animation: pulsate-red 0.5s; }
        .hud-item span { margin-left: 8px; }
        #combo-display { color: var(--primary-yellow); font-weight: bold; }

        /* Telas de Menu */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: flex-start; align-items: center;
            text-align: center; padding: 20px; box-sizing: border-box; z-index: 100;
            color: white; transition: opacity 0.5s, visibility 0.5s;
            overflow-y: auto;
        }
        .screen.hidden { opacity: 0; visibility: hidden; }
        .screen h1 {
            font-size: clamp(40px, 12vw, 60px);
            color: var(--primary-yellow);
            text-shadow: 4px 4px 0px var(--shadow-yellow), 0 0 30px var(--primary-yellow);
            margin-top: 40px;
            margin-bottom: 20px; animation: bounce-in 1s ease-out;
        }
        .screen h2 { font-size: clamp(30px, 8vw, 40px); margin-bottom: 20px; }
        .screen p { font-size: clamp(16px, 4vw, 22px); margin-bottom: 15px; max-width: 350px; }
        .screen .high-score, .screen .total-milk-display { font-size: clamp(18px, 5vw, 24px); color: var(--primary-yellow); margin: 10px 0 20px 0; text-shadow: 2px 2px 0 var(--shadow-yellow); }
        .screen .final-stars { font-size: clamp(40px, 12vw, 60px); margin: 20px 0; letter-spacing: 10px; }
        .screen button {
            font-family: 'Fredoka One', cursive; padding: 15px 30px; 
            font-size: clamp(18px, 5vw, 24px);
            color: var(--text-dark); background: linear-gradient(180deg, var(--primary-yellow), var(--secondary-yellow));
            border: none; border-radius: 15px; border-bottom: 6px solid var(--shadow-yellow);
            cursor: pointer; transition: all 0.1s ease-in-out; margin-top: 10px;
        }
        .screen button:hover { filter: brightness(1.1); }
        .screen button:active { transform: translateY(4px); border-bottom-width: 2px; }
        .screen button:disabled { filter: brightness(0.7); cursor: not-allowed; }
        
        .menu-selection { display: flex; flex-direction: column; gap: 15px; width: 100%; align-items: center; }
        .menu-selection button { width: 80%; max-width: 350px; display: flex; justify-content: center; align-items: center; gap: 15px;}
        .menu-selection button .icon { font-size: clamp(24px, 6vw, 30px); }
        #upgrades-button { background: #2ecc71; border-bottom-color: #27ae60; color: white;}
        #achievements-button { background: #3498db; border-bottom-color: #2980b9; color: white;}
        #choose-emoji-button { background: #9b59b6; border-bottom-color: #8e44ad; color: white;}
        
        /* Loja, Upgrades, Conquistas */
        .grid-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 100%; max-width: 350px; margin-bottom: 20px;}
        .emoji-item, .upgrade-item, .achievement-item { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 10px; }
        
        .emoji-button { font-size: 48px; width: 100%; padding: 10px 0; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 10px; }
        .emoji-button.selected { border-color: var(--primary-yellow); box-shadow: 0 0 20px var(--primary-yellow); }
        .price { font-size: 16px; display: flex; align-items: center; justify-content: center; gap: 5px; margin-top: 5px; }
        .price.unlocked { color: #2ecc71; }
        
        .upgrade-container { display: flex; flex-direction: column; gap: 15px; width: 100%; max-width: 380px; }
        .upgrade-item { display: grid; grid-template-columns: 1fr auto; align-items: center; text-align: left; padding: 15px; }
        .upgrade-info strong { display: block; font-size: 20px; }
        .upgrade-info .level { font-size: 14px; opacity: 0.8; }
        .upgrade-item button { padding: 10px 15px; font-size: 16px; margin-top: 0; }
        
        .achievement-container { display: flex; flex-direction: column; gap: 10px; width: 100%; max-width: 380px; }
        .achievement-item { display: flex; align-items: center; gap: 15px; text-align: left; padding: 15px; opacity: 0.5;}
        .achievement-item.unlocked { opacity: 1; border: 2px solid var(--primary-yellow); box-shadow: 0 0 10px var(--primary-yellow); }
        .achievement-icon { font-size: 40px; }
        .achievement-info strong { display: block; }
        .achievement-info span { font-size: 14px; opacity: 0.8; }
        
        .back-to-menu-button { margin-top: 40px; background: #7f8c8d; border-bottom-color: #606b6c; color: white;}
        
        /* Chefe e Comemorações */
        #boss-container { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); font-size: 80px; z-index: 20; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        #boss-container.visible { opacity: 1; }
        #boss-container.throw { animation: boss-throw 0.3s ease-out; }
        #boss-health-bar { position: absolute; top: 110px; left: 10%; width: 80%; height: 20px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid white; z-index: 10; padding: 2px; box-sizing: border-box; opacity: 0; transition: opacity 0.5s; }
        #boss-health { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #c0392b); border-radius: 6px; transition: width 0.5s ease-out; }
        #boss-health-bar.visible { opacity: 1; }
        #boss-arrival-text, #celebration-text {
            position: absolute; top: 40%; left: 50%;
            transform: translateX(-50%); font-size: 52px;
            color: #e74c3c; text-shadow: 3px 3px 0 black;
            z-index: 200; opacity: 0; pointer-events: none;
            width: 90%; text-align: center;
        }
        #celebration-text { color: var(--primary-yellow); text-shadow: 4px 4px 0px var(--shadow-yellow); transition: opacity 0.5s ease-out; }
        #boss-arrival-text.animate { animation: bounce-in 1.5s ease-out, fade-out 1.5s 2s forwards; }
        #celebration-text.animate { opacity: 1; animation: bounce-in 1s ease-out; }

        /* Animações */
        @keyframes fade-out { to { opacity: 0; transform: translateX(-50%) scale(1.5); } }
        @keyframes screen-shake { 0% { transform: translate(0, 0); } 25% { transform: translate(-5px, 5px); } 50% { transform: translate(5px, -5px); } 75% { transform: translate(-5px, 5px); } 100% { transform: translate(0, 0); }}
        @keyframes bounce-in { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.05); } 100% { transform: scale(1); opacity: 1; }}
        @keyframes boss-throw { 0% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.2) rotate(-5deg); } 100% { transform: translateX(-50%) scale(1); } }
        @keyframes pulsate-red { 50% { transform: scale(1.1); box-shadow: 0 0 15px red; } }

    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container" class="hidden">
            <div id="score" class="hud-item">🥛<span>0</span></div>
            <div id="combo-display" class="hud-item" style="display: none;">🔥<span>x1</span></div>
            <div id="lives" class="hud-item">❤️<span>3</span></div>
        </div>
        <div id="boss-container" class="hidden">🐵</div>
        <div id="boss-health-bar"><div id="boss-health"></div></div>
        <div id="boss-arrival-text"></div>
        <div id="celebration-text"></div>
        
        <!-- Telas de Menu -->
        <div id="main-menu" class="screen">
            <h1>Leite de Macho</h1>
            <p class="total-milk-display">Leite Total: 0</p>
            <div class="menu-selection">
                <button data-mode="levels"><span class="icon">🏆</span>Modo Fases</button>
                <button data-mode="infinite"><span class="icon">♾️</span>Modo Infinito</button>
                <button id="upgrades-button"><span class="icon">🚀</span>Melhorias</button>
                <button id="achievements-button"><span class="icon">🏅</span>Conquistas</button>
                <button id="choose-emoji-button"><span class="icon">😀</span>Loja de Emoji</button>
            </div>
            <p class="high-score" style="margin-top: 20px;">Recorde Infinito: 0</p>
        </div>

        <div id="level-select-screen" class="screen hidden">
            <h2>Selecionar Fase</h2>
            <div id="level-select-container"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <div id="emoji-select-screen" class="screen hidden">
            <h2>Loja de Personagens</h2>
            <p class="total-milk-display">Leite Total: 0</p>
            <div id="emoji-select-container" class="grid-container"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <div id="upgrades-screen" class="screen hidden">
            <h2>Melhorias</h2>
            <p class="total-milk-display">Leite Total: 0</p>
            <div id="upgrade-container" class="upgrade-container"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <div id="achievements-screen" class="screen hidden">
            <h2>Conquistas</h2>
            <div id="achievement-container" class="achievement-container"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <!-- Telas de Resultado -->
        <div id="level-complete-screen" class="screen hidden">
            <h1>Fase Completa!</h1>
            <div class="final-stars"></div>
            <button id="next-level-button">Próxima Fase</button>
            <button class="level-select-button">Escolher Fase</button>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h1>Fim de Jogo!</h1>
            <p id="final-score"></p>
            <p class="high-score"></p>
            <button id="restart-button">Tentar Novamente</button>
            <button class="level-select-button">Escolher Fase</button>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');

        // --- Elementos da UI ---
        const uiContainer = document.getElementById('ui-container');
        const scoreElement = document.querySelector('#score span');
        const livesElement = document.querySelector('#lives span');
        const comboDisplay = document.getElementById('combo-display');
        const comboMultiplierSpan = document.querySelector('#combo-display span');
        const bossContainer = document.getElementById('boss-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthFill = document.getElementById('boss-health');
        const bossArrivalText = document.getElementById('boss-arrival-text');
        const celebrationText = document.getElementById('celebration-text');
        
        // --- Menus e Telas ---
        const mainMenu = document.getElementById('main-menu');
        const levelSelectScreen = document.getElementById('level-select-screen');
        const levelSelectContainer = document.getElementById('level-select-container');
        const emojiSelectScreen = document.getElementById('emoji-select-screen');
        const emojiSelectContainer = document.getElementById('emoji-select-container');
        const upgradesScreen = document.getElementById('upgrades-screen');
        const upgradeContainer = document.getElementById('upgrade-container');
        const achievementsScreen = document.getElementById('achievements-screen');
        const achievementContainer = document.getElementById('achievement-container');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const finalScoreElement = document.getElementById('final-score');
        const finalStarsElement = document.querySelector('#level-complete-screen .final-stars');
        const highScoreDisplays = document.querySelectorAll('.high-score');
        const totalMilkDisplays = document.querySelectorAll('.total-milk-display');
        
        // --- Botões ---
        const modeButtons = document.querySelectorAll('.menu-selection button[data-mode]');
        const chooseEmojiButton = document.getElementById('choose-emoji-button');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const upgradesButton = document.getElementById('upgrades-button');
        const achievementsButton = document.getElementById('achievements-button');
        const restartButton = document.getElementById('restart-button');
        const nextLevelButton = document.getElementById('next-level-button');
        const backToMenuButtons = document.querySelectorAll('.back-to-menu-button');
        const toLevelSelectButtons = document.querySelectorAll('.level-select-button');

        function resizeCanvas() { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // --- Variáveis de Estado do Jogo ---
        let player, items, score, lives, gameOver, itemSpawnInterval, gameLoopId, particles, stars, highScore = 0, totalMilk = 0;
        let gameMode, currentLevel, levelGoal, levelStars, isInvincible = false, invincibilityTimer = 0;
        let isBossFightActive = false, bossState = {}, bossAttackInterval, bossSpecialItemInterval;
        let temporaryPlayerEmoji = null;
        let combo = { count: 0, multiplier: 1 };
        let slowedTimer = 0;
        let goldenMilkTimer = 0;
        let magnetTimer = 0;
        let nextCelebrationScore = 50;
        let nextBossScore = 100;

        // --- Constantes do Jogo ---
        const EMOJI_PRICES = { '�': 0, '😈': 100, '😎': 150, '😜': 200, '🤤': 300, '😼': 500 };
        const PLAYER_EMOJIS = Object.keys(EMOJI_PRICES);
        let unlockedEmojis = ['😏'];
        let PLAYER_EMOJI = '😏';
        
        const MILK_EMOJI = '🥛';
        const OBSTACLE_EMOJI = '🍆';
        const SHIELD_EMOJI = '🐅';
        const GLOWING_MILK_EMOJI = '✨';
        const HEART_EMOJI = '💖';
        const GOLDEN_MILK_EMOJI = '🌟';
        const MAGNET_EMOJI = '🧲';
        const SLOW_EMOJI = '🐌';
        
        const BOSSES = [
            { name: "Macaco Safado", emoji: "🐵", projectile: "🍌" },
            { name: "Touro Tarado", emoji: "🐂", projectile: "💨" },
            { name: "Polvo Pegajoso", emoji: "🐙", projectile: "💦" },
        ];
        
        const PLAYER_SIZE = 50;
        const ITEM_SIZE = 40;
        const LEVELS = [{ goal: 50 }, { goal: 100 }, { goal: 150 }, { goal: 200 }, { goal: 250 }];
        let highestLevelUnlocked = 1;
        
        const CELEBRATION_MESSAGES = ["Bela mamada!", "Que boca de veludo!", "Eita que delícia!", "Chupador profissional!", "A Cleide sem calcinha!", "Engole tudo!", "Boca de aspirador!", "Garganta de ouro!", "Nem piscou!", "Fez render!", "Talento nato!", "O rei da chupeta!", "Aceita tudo!", "Isso é que é gozo!", "Mandou bem!", "És o maior!"];
        
        // --- GESTÃO DE DADOS (localStorage) ---
        function loadData() {
            highScore = parseInt(localStorage.getItem('infiniteHighScore') || '0', 10);
            totalMilk = parseInt(localStorage.getItem('totalMilk') || '0', 10);
            highestLevelUnlocked = parseInt(localStorage.getItem('highestLevelUnlocked') || '1', 10);
            PLAYER_EMOJI = localStorage.getItem('playerEmoji') || '😏';
            unlockedEmojis = JSON.parse(localStorage.getItem('unlockedEmojis') || '["😏"]');
            
            const savedTheme = localStorage.getItem('gameTheme');
            if (savedTheme) {
                gameContainer.className = savedTheme;
            }
            updateUIDisplays();
        }

        function saveData() {
            if (gameMode === 'infinite' && score > highScore) {
                highScore = score;
                localStorage.setItem('infiniteHighScore', highScore);
            }
            localStorage.setItem('totalMilk', totalMilk);
            localStorage.setItem('unlockedEmojis', JSON.stringify(unlockedEmojis));
        }

        function unlockNextLevel() {
             if (gameMode === 'levels' && currentLevel === highestLevelUnlocked && currentLevel < LEVELS.length) {
                highestLevelUnlocked++;
                localStorage.setItem('highestLevelUnlocked', highestLevelUnlocked);
            }
        }
        
        function updateUIDisplays() {
             highScoreDisplays.forEach(el => el.textContent = `Recorde Infinito: ${highScore}`);
             totalMilkDisplays.forEach(el => el.textContent = `Leite Total: ${totalMilk}`);
        }
        
        // --- LÓGICA DE MENUS ---
        function showScreen(screen) { document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden')); if (screen) screen.classList.remove('hidden'); }
        
        function populateLevelSelect() {
            levelSelectContainer.innerHTML = '';
            for (let i = 1; i <= LEVELS.length; i++) {
                const button = document.createElement('button');
                button.textContent = i;
                button.dataset.level = i;
                if (i > highestLevelUnlocked) {
                    button.classList.add('locked');
                } else {
                    button.addEventListener('click', () => { currentLevel = i; initGame('levels'); });
                }
                levelSelectContainer.appendChild(button);
            }
        }
        
        function populateEmojiSelect() {
            emojiSelectContainer.innerHTML = '';
            PLAYER_EMOJIS.forEach(emoji => {
                const isUnlocked = unlockedEmojis.includes(emoji);
                const price = EMOJI_PRICES[emoji];

                const itemDiv = document.createElement('div');
                itemDiv.className = 'emoji-item';

                const button = document.createElement('button');
                button.className = 'emoji-button';
                button.textContent = emoji;
                if (emoji === PLAYER_EMOJI) button.classList.add('selected');

                const priceDiv = document.createElement('div');
                priceDiv.className = 'emoji-price';

                if (isUnlocked) {
                    priceDiv.textContent = '✔️';
                    priceDiv.classList.add('unlocked');
                    button.addEventListener('click', () => {
                        PLAYER_EMOJI = emoji;
                        localStorage.setItem('playerEmoji', emoji);
                        populateEmojiSelect();
                    });
                } else {
                    priceDiv.innerHTML = `🥛 <span>${price}</span>`;
                    if (totalMilk >= price) {
                        button.addEventListener('click', () => buyEmoji(emoji, price));
                    } else {
                        button.disabled = true;
                    }
                }

                itemDiv.appendChild(button);
                itemDiv.appendChild(priceDiv);
                emojiSelectContainer.appendChild(itemDiv);
            });
        }
        
        function buyEmoji(emoji, price) {
            if (totalMilk >= price) {
                totalMilk -= price;
                unlockedEmojis.push(emoji);
                PLAYER_EMOJI = emoji;
                localStorage.setItem('playerEmoji', emoji);
                saveData();
                updateUIDisplays();
                populateEmojiSelect();
            }
        }

        function showCelebration() {
            const message = CELEBRATION_MESSAGES[Math.floor(Math.random() * CELEBRATION_MESSAGES.length)];
            celebrationText.textContent = message;
            celebrationText.classList.add('animate');
            setTimeout(() => {
                celebrationText.classList.remove('animate');
            }, 3000); // Duração da animação
        }

        // --- LÓGICA PRINCIPAL DO JOGO ---
        function initGame(mode) {
            gameMode = mode;
            score = 0; 
            lives = 3; gameOver = false; particles = []; items = [];
            isInvincible = false; invincibilityTimer = 0;
            isBossFightActive = false;
            combo = { count: 0, multiplier: 1 };
            slowedTimer = 0; goldenMilkTimer = 0; magnetTimer = 0;
            nextCelebrationScore = 50;
            nextBossScore = 100;
            
            if (gameMode === 'levels') { levelGoal = LEVELS[currentLevel - 1].goal; levelStars = 3; } else { levelGoal = -1; }
            player = { x: canvas.width / 2 - PLAYER_SIZE / 2, y: canvas.height - PLAYER_SIZE - 20, width: PLAYER_SIZE, height: PLAYER_SIZE, speed: 6, bobble: 0, scaleX: 1, scaleY: 1 }; // Velocidade inicial reduzida
            if (!stars) createStars();

            updateUI();
            showScreen(null);
            uiContainer.classList.remove('hidden');

            if (itemSpawnInterval) clearInterval(itemSpawnInterval);
            itemSpawnInterval = setInterval(spawnItem, 800);

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop();
        }

        function gameLoop() {
            if (gameOver) return;
            const currentSpeed = (slowedTimer > 0) ? player.speed / 2 : player.speed;
            let playerSpeedX = 0;
            if (keys['ArrowLeft'] || keys['a']) playerSpeedX = -currentSpeed;
            if (keys['ArrowRight'] || keys['d']) playerSpeedX = currentSpeed;
            player.x += playerSpeedX;
            player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(playerSpeedX);
            drawPlayer();
            updateItems();
            drawItems();
            if(isBossFightActive) updateBoss();

            if (isInvincible) invincibilityTimer--;
            if (slowedTimer > 0) slowedTimer--;
            if (goldenMilkTimer > 0) goldenMilkTimer--;
            if (magnetTimer > 0) magnetTimer--;

            if(isInvincible && invincibilityTimer <= 0) isInvincible = false;
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function triggerPlayerAnimation(type) {
            if (type === 'collect') { temporaryPlayerEmoji = '😋'; } 
            else if (type === 'damage') {
                temporaryPlayerEmoji = '😵';
                player.damageFlash = 10;
                const livesHud = document.querySelector('#lives');
                livesHud.classList.add('pulsate');
                setTimeout(() => livesHud.classList.remove('pulsate'), 500);
            }
            setTimeout(() => { temporaryPlayerEmoji = null; }, 300);
        }
        
        function resetCombo() {
            combo.count = 0;
            combo.multiplier = 1;
            comboDisplay.style.display = 'none';
        }

        function updateItems() {
            const speedMultiplier = 1 + Math.floor(score / 50) * 0.05;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];

                if (item.type === 'projectile') { item.x += item.speedX; item.y += item.speedY; } 
                else {
                    if (magnetTimer > 0 && (item.type === 'milk' || item.type === 'golden-milk')) {
                        const dx = (player.x + player.width / 2) - (item.x + ITEM_SIZE / 2);
                        item.x += dx * 0.05;
                    }
                    item.y += item.speed * speedMultiplier;
                }

                if (item.y + ITEM_SIZE > player.y && item.y < player.y + player.height && item.x + ITEM_SIZE > player.x && item.x < player.x + player.width) {
                    if (item.type === 'shield') { isInvincible = true; invincibilityTimer = 180; score += 2; triggerPlayerAnimation('collect'); createParticles(item.x, item.y, 'gold', 40); } 
                    else if (item.type === 'heart') { if (lives < 3) lives++; createParticles(item.x, item.y, 'pink', 30); }
                    else if (item.type === 'golden-milk') { goldenMilkTimer = 300; createParticles(item.x, item.y, 'gold', 50); }
                    else if (item.type === 'magnet') { magnetTimer = 300; createParticles(item.x, item.y, '#8e44ad', 40); }
                    else if (item.type === 'glowing-milk') { bossState.health--; createParticles(player.x, player.y, 'cyan', 30); items.push({ x: player.x, y: player.y, type: 'hit-projectile' }); }
                    else if (item.type === 'milk') {
                        const pointsToAdd = goldenMilkTimer > 0 ? 2 * combo.multiplier : 1 * combo.multiplier;
                        score += pointsToAdd;
                        combo.count++;
                        if (combo.count >= 5) combo.multiplier = 2;
                        if (combo.count >= 10) combo.multiplier = 3;
                        comboDisplay.style.display = 'flex';
                        comboMultiplierSpan.textContent = `x${combo.multiplier}`;
                        triggerPlayerAnimation('collect');
                        if (score >= nextBossScore && !isBossFightActive) {
                            startBossFight();
                        } else if (score >= nextCelebrationScore && !isBossFightActive) {
                            showCelebration();
                            nextCelebrationScore += 50;
                        }
                        createParticles(item.x, item.y, 'white', 25);
                        if (gameMode === 'levels' && score >= levelGoal) levelComplete();
                    } else if (item.type === 'obstacle' || item.type === 'projectile' || item.type === 'slow') {
                        if (!isInvincible) {
                            lives--;
                            resetCombo();
                            triggerPlayerAnimation('damage');
                            if (item.type === 'slow') slowedTimer = 300;
                            if (gameMode === 'levels') levelStars = Math.max(1, levelStars - 1);
                            const particleColor = item.type === 'obstacle' ? '#8e44ad' : (item.type === 'projectile' ? bossState.projectileColor : 'cyan');
                            createParticles(item.x, item.y, particleColor, 35);
                            gameContainer.classList.add('shake');
                            setTimeout(() => gameContainer.classList.remove('shake'), 200);
                        } else { createParticles(item.x, item.y, 'lightgray', 15); }
                    }
                    if (item.type !== 'hit-projectile') items.splice(i, 1);
                    updateUI();
                    if (lives <= 0) endGame();
                    continue;
                }
                
                if(item.type === 'hit-projectile') {
                    const bossYPos = bossContainer.offsetTop + bossContainer.offsetHeight;
                    item.y -= 20;
                    if(item.y < bossYPos) {
                        createParticles(bossContainer.offsetLeft + bossContainer.offsetWidth / 2, bossYPos, 'red', 50);
                        items.splice(i, 1);
                    }
                }
                
                if (item.y > canvas.height) { if(item.type === 'milk') resetCombo(); items.splice(i, 1); }
            }
        }
        
        function startBossFight() {
            isBossFightActive = true;
            const currentBossIndex = Math.floor((nextBossScore / 100) - 1) % BOSSES.length;
            const currentBoss = BOSSES[currentBossIndex];

            bossArrivalText.textContent = `O ${currentBoss.name} CHEGOU!`;
            bossContainer.textContent = currentBoss.emoji;
            bossArrivalText.classList.add('animate');
            bossArrivalText.addEventListener('animationend', () => bossArrivalText.classList.remove('animate'), {once: true});
            clearInterval(itemSpawnInterval);
            bossState = { health: 5, maxHealth: 5, ...currentBoss };
            bossContainer.classList.add('visible');
            bossHealthBar.classList.add('visible');
            bossAttackInterval = setInterval(() => { if(!gameOver) spawnItem('projectile'); }, 2000);
            bossSpecialItemInterval = setInterval(() => { if(!gameOver) spawnItem('glowing-milk'); }, 3000);
        }

        function updateBoss() {
            bossHealthFill.style.width = `${(bossState.health / bossState.maxHealth) * 100}%`;
            if(bossState.health <= 0) endBossFight();
        }
        
        function endBossFight() {
            isBossFightActive = false;
            nextBossScore += 100;
            const bossRect = bossContainer.getBoundingClientRect();
            createParticles(bossRect.left + bossRect.width/2, bossRect.top + bossRect.height/2, 'gold', 150);
            bossContainer.classList.remove('visible');
            bossHealthBar.classList.remove('visible');
            clearInterval(bossAttackInterval);
            clearInterval(bossSpecialItemInterval);
            itemSpawnInterval = setInterval(spawnItem, 800);
            score += 250;
            updateUI();
        }

        function endGame() {
            gameOver = true;
            clearInterval(itemSpawnInterval);
            if(isBossFightActive) { clearInterval(bossAttackInterval); clearInterval(bossSpecialItemInterval); }
            uiContainer.classList.add('hidden');
            bossContainer.classList.remove('visible');
            bossHealthBar.classList.remove('visible');
            totalMilk += score;
            saveData();
            updateUIDisplays();
            finalScoreElement.textContent = `Apanhaste ${score} leitadas.`;
            showScreen(gameOverScreen);
            
            if (gameMode === 'infinite') {
                gameOverScreen.querySelector('.level-select-button').style.display = 'none';
            } else {
                gameOverScreen.querySelector('.level-select-button').style.display = 'block';
            }
        }
        
        function levelComplete() {
            gameOver = true;
            clearInterval(itemSpawnInterval);
            uiContainer.classList.add('hidden');
            totalMilk += score;
            unlockNextLevel();
            saveData();
            finalStarsElement.innerHTML = '⭐'.repeat(levelStars) + '☆'.repeat(3 - levelStars);
            nextLevelButton.style.display = (currentLevel < LEVELS.length) ? 'inline-block' : 'none';
            showScreen(levelCompleteScreen);
        }

        function updateUI() {
            scoreElement.textContent = gameMode === 'levels' ? `${score} / ${levelGoal}` : score;
            livesElement.textContent = lives;
        }
        
        function createStars() { stars = Array.from({length: 150}, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, parallax: 0.2 + Math.random() * 0.8 })); }
        function drawStars(playerSpeedX) { stars.forEach(star => { star.x -= playerSpeedX * star.parallax * 0.1; if (star.x < 0) star.x = canvas.width; if (star.x > canvas.width) star.x = 0; const flicker = Math.sin(Date.now() * 0.002 + star.x) * 0.2 + 0.8; ctx.fillStyle = `rgba(255, 255, 255, ${flicker})`; ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill(); }); }
        function createParticles(x, y, color, count) { particles = particles || []; Array.from({length: count}).forEach(() => particles.push({ x, y, color, size: Math.random() * 6 + 2, speedX: (Math.random() - 0.5) * 6, speedY: (Math.random() - 0.5) * 6, life: 40 })); }
        function updateAndDrawParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.speedX; p.y += p.speedY; p.speedY += 0.1; p.life--; if (p.life <= 0) { particles.splice(i, 1); } else { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 40; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; } } }
        
        function drawPlayer() { 
            if (!player) return; 
            player.bobble += 0.1; 
            const yOffset = Math.sin(player.bobble) * 3; 
            ctx.save(); 
            ctx.translate(player.x + player.width / 2, player.y + player.height + yOffset); 
            ctx.scale(player.scaleX, player.scaleY); 
            
            if (isInvincible) { ctx.shadowColor = "gold"; ctx.shadowBlur = 20; } 
            else if (player.damageFlash > 0) {
                 ctx.shadowColor = "red"; ctx.shadowBlur = 20;
                 player.damageFlash--;
            }
            else if (slowedTimer > 0) {
                ctx.shadowColor = "cyan"; ctx.shadowBlur = 15;
            }
            else { ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowBlur = 15; }

            ctx.font = `${PLAYER_SIZE}px sans-serif`; 
            ctx.shadowOffsetX = 0; 
            ctx.shadowOffsetY = 8; 
            ctx.fillText(temporaryPlayerEmoji || PLAYER_EMOJI, -player.width / 2, 0); 
            ctx.restore(); 
            player.scaleX += (1 - player.scaleX) * 0.2; 
            player.scaleY += (1 - player.scaleY) * 0.2; 
        }
        
        function drawItems() { ctx.font = `${ITEM_SIZE}px sans-serif`; for (const item of items) { let emoji; if(item.type === 'hit-projectile') emoji = MILK_EMOJI; else if (item.type === 'milk') emoji = MILK_EMOJI; else if (item.type === 'obstacle') emoji = OBSTACLE_EMOJI; else if (item.type === 'projectile') emoji = bossState.projectile; else if (item.type === 'heart') emoji = HEART_EMOJI; else if (item.type === 'slow') emoji = SLOW_EMOJI; else if (item.type === 'magnet') emoji = MAGNET_EMOJI; else if (item.type === 'golden-milk') emoji = GOLDEN_MILK_EMOJI; else emoji = SHIELD_EMOJI; const pulse = item.type === 'glowing-milk' || item.type === 'golden-milk' ? 1.5 + Math.sin(Date.now()*0.01)*0.3 : 1; ctx.save(); ctx.translate(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2); if (item.type === 'shield' || item.type === 'glowing-milk' || item.type === 'heart' || item.type === 'golden-milk') { ctx.shadowColor = "gold"; ctx.shadowBlur = 20; } ctx.scale(pulse, pulse); ctx.rotate(item.rotation); ctx.fillText(emoji, -ITEM_SIZE / 2, ITEM_SIZE / 2); ctx.restore(); } }
        
        function spawnItem(typeOverride = null) {
            const x = Math.random() * (canvas.width - ITEM_SIZE);
            let type, speed = 2.5 + Math.random() * 3.5;
            
            if (typeOverride) {
                type = typeOverride;
                if(type === 'projectile'){
                    bossContainer.classList.add('throw');
                    setTimeout(() => bossContainer.classList.remove('throw'), 300);
                    const bossX = bossContainer.offsetLeft + bossContainer.offsetWidth / 2;
                    const bossY = bossContainer.offsetTop + bossContainer.offsetHeight / 2;
                    const dx = player.x - bossX;
                    const dy = player.y - bossY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    items.push({ x: bossX, y: bossY, speedX: (dx/dist)*5, speedY: (dy/dist)*5, type: 'projectile'});
                    return;
                }
            } else {
                const rand = Math.random(); 
                if (rand < 0.02) { type = 'golden-milk'; }
                else if (rand < 0.05) { type = 'magnet'; }
                else if (rand < 0.08) { type = 'shield'; }       
                else if (rand < 0.12 && score >= 50) { type = 'heart'; }  
                else if (rand < 0.70) { type = 'milk'; } 
                else if (rand < 0.85) { type = 'slow'; }
                else { type = 'obstacle'; }                 
            }
             items.push({ x, y: -ITEM_SIZE, speed, type, rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.1 });
        }

        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);
        function handleMovement() { if (!player || gameOver) { requestAnimationFrame(handleMovement); return; } if (keys['ArrowLeft'] || keys['a']) { player.x -= player.speed; player.scaleX = 1.1; player.scaleY = 0.9; } if (keys['ArrowRight'] || keys['d']) { player.x += player.speed; player.scaleX = 1.1; player.scaleY = 0.9; } player.x = Math.max(0, Math.min(player.x, canvas.width - player.width)); requestAnimationFrame(handleMovement); }
        function movePlayer(clientX) { if (!player || gameOver) return; const rect = canvas.getBoundingClientRect(); const lastX = player.x; player.x = clientX - rect.left - player.width / 2; if (Math.abs(player.x - lastX) > 2) { player.scaleX = 1.1; player.scaleY = 0.9; } }
        canvas.addEventListener('mousemove', (e) => movePlayer(e.clientX));
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); movePlayer(e.touches[0].clientX); });

        // --- EVENTOS DOS BOTÕES DO MENU ---
        modeButtons.forEach(button => { button.addEventListener('click', () => { const mode = button.dataset.mode; if (mode === 'infinite') { initGame('infinite'); } else { populateLevelSelect(); showScreen(levelSelectScreen); } }); });
        chooseEmojiButton.addEventListener('click', () => { populateEmojiSelect(); showScreen(emojiSelectScreen); });
        
        // FIX: Adiciona verificações para os botões que podem não existir
        if (upgradesButton) {
            upgradesButton.addEventListener('click', () => { /* A ser implementado */ showScreen(upgradesScreen); });
        }
        if (achievementsButton) {
            achievementsButton.addEventListener('click', () => { /* A ser implementado */ showScreen(achievementsScreen); });
        }
        if (themeToggleButton) {
            themeToggleButton.addEventListener('click', () => {
                const root = document.documentElement;
                const currentTheme = gameContainer.className || 'theme-night';
                const themes = ['theme-night', 'theme-day', 'theme-hell', 'theme-candy', 'theme-forest', 'theme-space'];
                const nextThemeIndex = (themes.indexOf(currentTheme) + 1) % themes.length;
                gameContainer.className = themes[nextThemeIndex];
                localStorage.setItem('gameTheme', themes[nextThemeIndex]);
            });
        }
        backToMenuButtons.forEach(button => { button.addEventListener('click', () => showScreen(mainMenu)); });
        toLevelSelectButtons.forEach(button => { button.addEventListener('click', () => { populateLevelSelect(); showScreen(levelSelectScreen); }); });
        restartButton.addEventListener('click', () => { initGame(gameMode); });
        nextLevelButton.addEventListener('click', () => { currentLevel++; initGame('levels'); });
        
        // Inicia tudo
        loadData();
        handleMovement();

    </script>
</body>
</html>
�
