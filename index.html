<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Sirilo e o Leite de Macho</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-yellow: #ffde59;
            --secondary-yellow: #ffc300;
            --shadow-yellow: #c78f00;
            --text-dark: #3d2b00;
            --bg-dark: #141e30;
            --bg-light: #243b55;
            --ground: #1e8449; /* Darker green */
            --border: #fff;
            --purple-light: #9b59b6;
            --purple-dark: #8e44ad;
            --orange-light: #e67e22;
            --orange-dark: #d35400;
        }

        html, body {
            margin: 0; padding: 0; font-family: 'Fredoka One', cursive;
            width: 100%; height: 100%; overflow: hidden;
            background-color: #0c0c1e; display: flex;
            justify-content: center; align-items: center; touch-action: manipulation;
        }

        #game-container {
            width: 100%; height: 100%;
            max-width: 500px; max-height: 100vh;
            background: linear-gradient(to bottom, var(--bg-dark), var(--bg-light));
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            position: relative; overflow: hidden;
            border: 5px solid var(--border);
            border-bottom: 15px solid var(--ground);
            border-radius: 25px;
            display: flex; flex-direction: column;
        }
        
        #game-canvas { width: 100%; height: 100%; display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* Screens, Menus and Modals */
        .screen, .modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(12, 12, 30, 0.7); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 20px; box-sizing: border-box; z-index: 100;
            color: white; transition: opacity 0.4s ease, visibility 0.4s ease;
        }
        .screen.hidden, .modal-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        .screen { justify-content: flex-start; overflow-y: auto; }
        
        .modal-content {
            background: linear-gradient(145deg, var(--bg-light), var(--bg-dark)); 
            padding: 30px; border-radius: 20px; border: 3px solid var(--border);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5); width: 90%; max-width: 350px;
            animation: pop-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-content h2 { font-size: 28px; margin-top: 0; color: var(--primary-yellow); }
        .modal-content input {
            width: calc(100% - 28px); padding: 14px; margin: 15px 0; border-radius: 10px; border: 2px solid var(--border);
            background: rgba(0,0,0,0.2); color: white; font-family: 'Fredoka One', cursive; font-size: 18px;
            text-align: center; box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
        }
        
        .screen h1 {
            font-size: clamp(40px, 12vw, 65px); color: var(--primary-yellow);
            text-shadow: 4px 4px 0px var(--shadow-yellow), 0 0 35px var(--primary-yellow);
            margin-top: 20px; margin-bottom: 10px; animation: bounce-in 1s ease-out;
        }
        .screen h2 { font-size: clamp(30px, 8vw, 40px); margin-bottom: 20px; }
        .screen p { font-size: clamp(16px, 4vw, 22px); margin-bottom: 15px; max-width: 350px; line-height: 1.4; }
        .screen .high-score, .screen .total-milk-display { 
            font-size: clamp(18px, 5vw, 24px); color: var(--primary-yellow); 
            margin: 5px 0 15px 0; text-shadow: 2px 2px 0 var(--shadow-yellow); 
            background: rgba(0,0,0,0.2); padding: 8px 15px; border-radius: 15px;
        }

        /* Buttons */
        .screen button, .modal-content button {
            font-family: 'Fredoka One', cursive; padding: 15px 30px; 
            font-size: clamp(18px, 5vw, 24px);
            color: var(--text-dark); background: linear-gradient(180deg, var(--primary-yellow), var(--secondary-yellow));
            border: none; border-radius: 15px; border-bottom: 6px solid var(--shadow-yellow);
            cursor: pointer; transition: all 0.1s ease-in-out; margin-top: 10px;
            text-shadow: 1px 1px 0 rgba(255,255,255,0.3);
        }
        .screen button:hover, .modal-content button:hover { filter: brightness(1.1); transform: translateY(-2px); }
        .screen button:active, .modal-content button:active { transform: translateY(4px); border-bottom-width: 2px; }
        .screen button:disabled, .modal-content button:disabled { filter: brightness(0.6) grayscale(0.6); cursor: not-allowed; border-bottom-width: 6px; transform: translateY(0); }
        
        .menu-selection { display: flex; flex-direction: column; gap: 15px; width: 100%; align-items: center; }
        .menu-selection button { width: 90%; max-width: 380px; display: flex; justify-content: center; align-items: center; gap: 15px;}
        .menu-selection button .icon { font-size: clamp(24px, 6vw, 30px); }
        #ranking-button { background: linear-gradient(180deg, var(--orange-light), var(--orange-dark)); border-bottom-color: #a04000; color: white;}
        #choose-emoji-button { background: linear-gradient(180deg, var(--purple-light), var(--purple-dark)); border-bottom-color: #7d3c98; color: white;}
        .back-to-menu-button { background: #7f8c8d; border-bottom-color: #606b6c; color: white; margin-top: auto; padding-top: 20px;}
        
        /* Ranking */
        #ranking-list { list-style: none; width: 100%; max-width: 380px; padding: 0; margin-top: 20px; }
        #ranking-list li {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.25); padding: 12px 18px; border-radius: 10px;
            margin-bottom: 10px; font-size: 18px; border-left: 5px solid var(--secondary-yellow);
        }
        #ranking-list li .rank { font-weight: bold; color: var(--primary-yellow); min-width: 30px; text-align: left; }
        #ranking-list li .name { flex-grow: 1; text-align: left; margin-left: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #ranking-list li .score { font-weight: bold; color: #fff; }
        #ranking-list .loading { font-size: 20px; margin-top: 30px; text-align: center; }

        /* Emoji Store */
        #emoji-select-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 15px; width: 100%; max-width: 400px; margin-bottom: 20px; }
        .emoji-item { background: rgba(0,0,0,0.2); border-radius: 15px; padding: 10px; text-align: center; transition: transform 0.2s ease; }
        .emoji-item:hover { transform: scale(1.05); }
        .emoji-button { font-size: 50px; background: none; border: none; cursor: pointer; padding: 10px; width: 100%; border-radius: 10px; transition: background-color 0.2s; }
        .emoji-button:hover { background: rgba(255,255,255,0.1); }
        .emoji-button.selected { background: var(--primary-yellow); box-shadow: 0 0 15px var(--primary-yellow); }
        .emoji-item .price { margin-top: 5px; font-size: 16px; color: var(--primary-yellow); }
        .emoji-item .price.unlocked { color: #2ecc71; font-weight: bold; }
        .emoji-button:disabled { filter: grayscale(1); cursor: not-allowed; }

        /* UI and Animations */
        #ui-container { position: absolute; top: 15px; left: 15px; right: 15px; display: flex; justify-content: space-between; align-items: center; gap: 10px; z-index: 10; pointer-events: none; }
        .hud-item { background: rgba(0, 0, 0, 0.3); padding: 8px 15px; border-radius: 20px; border: 2px solid rgba(255, 255, 255, 0.3); display: flex; align-items: center; font-size: clamp(16px, 4vw, 24px); color: white; text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2); }
        .hud-item.pulsate { animation: pulsate-red 0.5s; }
        #combo-display { color: var(--primary-yellow); font-weight: bold; }
        #boss-container { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); font-size: 80px; z-index: 5; opacity: 0; transition: opacity 0.5s, transform 0.3s; pointer-events: none; }
        #boss-container.visible { opacity: 1; }
        #boss-container.throw { animation: boss-throw 0.3s ease-out; }
        #boss-container.hit { animation: boss-hit 0.2s; }
        #boss-health-bar { position: absolute; top: 110px; left: 10%; width: 80%; height: 20px; background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid white; z-index: 10; padding: 2px; box-sizing: border-box; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        #boss-health { width: 100%; height: 100%; background: linear-gradient(to right, #e74c3c, #c0392b); border-radius: 6px; transition: width 0.5s ease-out; }
        #boss-health-bar.visible { opacity: 1; }
        
        #boss-arrival-text, #celebration-text {
            position: absolute; top: 45%; left: 50%;
            font-size: clamp(32px, 10vw, 52px); color: #e74c3c;
            text-shadow: 3px 3px 0 black, 0 0 20px #e74c3c; z-index: 200;
            opacity: 0; pointer-events: none; width: 90%; text-align: center;
            transform: translate(-50%, -50%) scale(0.5);
        }
        #boss-arrival-text.animate, #celebration-text.animate { animation: text-pop-up 2s forwards; }
        #celebration-text { color: var(--primary-yellow); text-shadow: 4px 4px 0px var(--shadow-yellow), 0 0 25px var(--primary-yellow); }

        @keyframes text-pop-up {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20%, 80% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        @keyframes pop-in { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        @keyframes screen-shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-5px, 5px); } 50% { transform: translate(5px, -5px); } 75% { transform: translate(-5px, 5px); } }
        @keyframes bounce-in { 0% { transform: scale(0.5); opacity: 0; } 70% { transform: scale(1.05); } 100% { transform: scale(1); opacity: 1; }}
        @keyframes boss-throw { 0% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(1.2) rotate(-5deg); } 100% { transform: translateX(-50%) scale(1); } }
        @keyframes boss-hit { 0%, 100% { transform: translateX(-50%) scale(1); } 50% { transform: translateX(-50%) scale(0.9) rotate(5deg); filter: brightness(3); } }
        @keyframes pulsate-red { 50% { transform: scale(1.1); box-shadow: 0 0 15px red; } }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container" class="hidden">
            <div id="score" class="hud-item">🥛<span>0</span></div>
            <div id="combo-display" class="hud-item" style="display: none;">🔥<span>x1</span></div>
            <div id="lives" class="hud-item">❤️<span>3</span></div>
        </div>
        <div id="boss-container">🐵</div>
        <div id="boss-health-bar" class="hidden"><div id="boss-health"></div></div>
        <div id="boss-arrival-text"></div>
        <div id="celebration-text"></div>

        <div id="main-menu" class="screen">
            <h1>Leite de Macho</h1>
            <p class="total-milk-display">Leite Total: 0</p>
            <div class="menu-selection">
                <button data-mode="levels"><span class="icon">🏆</span>Modo Fases</button>
                <button data-mode="infinite"><span class="icon">♾️</span>Modo Infinito</button>
                <button id="ranking-button"><span class="icon">👑</span>Meus Recordes</button>
                <button id="choose-emoji-button"><span class="icon">😀</span>Loja de Emoji</button>
            </div>
            <p class="high-score" style="margin-top: 20px;">Recorde Infinito: 0</p>
        </div>

        <div id="ranking-screen" class="screen hidden">
            <h2>Meus Recordes</h2>
            <ul id="ranking-list"><li class="loading">Nenhum recorde salvo.</li></ul>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>

        <div id="level-select-screen" class="screen hidden">
            <h2>Selecionar Fase</h2>
            <div id="level-select-container" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; max-width: 350px;"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <div id="emoji-select-screen" class="screen hidden">
            <h2>Loja de Personagens</h2>
            <p class="total-milk-display">Leite Total: 0</p>
            <div id="emoji-select-container"></div>
            <button class="back-to-menu-button">Menu Principal</button>
        </div>
        
        <div id="game-over-screen" class="screen hidden">
            <h1>Fim de Jogo!</h1>
            <p id="final-score"></p>
            <p class="high-score"></p>
            <div id="name-input-container" class="hidden">
                <p>Novo Recorde! Digite seu nome:</p>
                <input type="text" id="player-name-input" placeholder="Seu Nome" maxlength="15">
                <button id="save-score-button">Salvar</button>
            </div>
            <div id="game-over-buttons">
                <button id="restart-button">Tentar Novamente</button>
                <button class="level-select-button" style="display:none;">Escolher Fase</button>
                <button class="back-to-menu-button">Menu Principal</button>
            </div>
        </div>

        <div id="level-complete-screen" class="screen hidden">
            <h1>Fase Completa!</h1>
            <div class="final-stars" style="font-size: clamp(40px, 12vw, 60px); margin: 20px 0; letter-spacing: 10px;"></div>
            <button id="next-level-button">Próxima Fase</button>
            <button class="level-select-button">Escolher Fase</button>
        </div>
    </div>

    <script type="module">
        // --- Game Constants and Variables ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        
        // --- UI Elements ---
        const allScreens = document.querySelectorAll('.screen');
        const mainMenu = document.getElementById('main-menu');
        const rankingScreen = document.getElementById('ranking-screen');
        const levelSelectScreen = document.getElementById('level-select-screen');
        const emojiSelectScreen = document.getElementById('emoji-select-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const nameInputContainer = document.getElementById('name-input-container');
        const gameOverButtons = document.getElementById('game-over-buttons');
        const uiContainer = document.getElementById('ui-container');
        const scoreElement = document.querySelector('#score span');
        const livesElement = document.querySelector('#lives span');
        const comboDisplay = document.getElementById('combo-display');
        const comboMultiplierSpan = document.querySelector('#combo-display span');
        const finalScoreElement = document.getElementById('final-score');
        const highScoreDisplays = document.querySelectorAll('.high-score');
        const totalMilkDisplays = document.querySelectorAll('.total-milk-display');
        const rankingList = document.getElementById('ranking-list');
        const emojiSelectContainer = document.getElementById('emoji-select-container');
        const levelSelectContainer = document.getElementById('level-select-container');
        const bossContainer = document.getElementById('boss-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthFill = document.getElementById('boss-health');
        const bossArrivalText = document.getElementById('boss-arrival-text');
        const celebrationText = document.getElementById('celebration-text');
        
        // --- Game State ---
        let player, items, score, lives, gameOver, itemSpawnInterval, gameLoopId, particles, stars, bossAttackInterval, bossSpecialItemInterval;
        let gameMode, currentLevel, levelGoal, levelStars, highScore = 0, totalMilk = 0;
        let localScores = [];
        let isInvincible = false, invincibilityTimer = 0;
        let isBossFightActive = false, bossState = {};
        let milkSinceLastBoss = 0;
        let combo = { count: 0, multiplier: 1 };
        let slowedTimer = 0, goldenMilkTimer = 0, magnetTimer = 0;
        let nextCelebrationScore = 50;
        let keys = {};
        
        // --- Game Constants ---
        const EMOJI_PRICES = { '😏': 0, '😈': 100, '😎': 150, '😜': 200, '🤤': 300, '😼': 500, '🥵': 750, '🤡': 1000 };
        const PLAYER_EMOJIS = Object.keys(EMOJI_PRICES);
        let unlockedEmojis = ['😏'];
        let PLAYER_EMOJI = '😏';
        const MILK_EMOJI = '🥛', OBSTACLE_EMOJI = '🍆', SHIELD_EMOJI = '🐅', GLOWING_MILK_EMOJI = '✨', HEART_EMOJI = '💖', GOLDEN_MILK_EMOJI = '🌟', MAGNET_EMOJI = '🧲', SLOW_EMOJI = '�';
        const BOSSES = [
            { name: "Macaco Safado", emoji: "🐵", projectile: "🍌" },
            { name: "Touro Tarado", emoji: "🐂", projectile: "💨" },
            { name: "Polvo Pegajoso", emoji: "🐙", projectile: "💦" },
            { name: "Diabo Sedutor", emoji: "😈", projectile: "🔥" },
            { name: "Fantasma Assanhado", emoji: "👻", projectile: "💧" },
        ];
        const PLAYER_SIZE = 50, ITEM_SIZE = 40;
        const LEVELS = Array.from({ length: 20 }, (_, i) => ({ goal: 50 + i * 25 }));
        let highestLevelUnlocked = 1;
        
        // --- NEW CELEBRATION MESSAGES ---
        const CELEBRATION_MESSAGES = [
            "Bela mamada!", "Que boca de veludo!", "Eita que delícia!", "Chupador profissional!", "A Cleide sem calcinha!", "Engole tudo!", "Boca de aspirador!", "Garganta de ouro!", "Nem piscou!", "Fez render!", "Talento nato!", "O rei da chupeta!", "Aceita tudo!", "Isso é que é gozo!", "Mandou bem!", "És o maior!",
            "Hidratado!", "Leite é vida!", "Mais um pra conta!", "Sabor inigualável!", "Gole de campeão!", "O terror dos leites!", "Profundo e eficiente!", "Até a última gota!", "Mestre da sucção!", "Um artista!", "Que performance!", "Incrível!", "Espetacular!", "Divino!", "Sem desperdício!", "Absorção total!", "Garganta profunda!", "Pura habilidade!", "Gênio da mamada!", "O insaciável!", "Lactofilia em ação!", "Ídolo!", "Lenda!", "Monstro!", "O escolhido!", "Que sede!", "Glup, glup!", "Delícia cremosa!", "Néctar dos deuses!", "Mais, quero mais!", "Energia pura!", "Fome de leite!", "Viciado em laticínios!", "O papa-leite!", "Sem limites!", "Imparável!", "Sempre cabe mais um!", "Boca nervosa!", "Isso sim é talento!", "Um dom divino!", "Craque da degustação!", "O sommelier de leite!", "Nota 10!", "Magnífico!", "Impressionante!", "Que categoria!", "Classe mundial!", "Nível hard!", "Descomunal!", "Abusado!", "Sem educação!", "Atrevido!", "Um guloso!", "Boca santa!", "Que benção!", "Alimentando a alma!", "Direto na fonte!", "Com vontade!", "Sede de vitória!", "O predador de leites!", "Um verdadeiro apreciador!", "Satisfação garantida!", "Missão cumprida!", "Trabalho bem feito!", "Com maestria!", "Um show!", "Que espetáculo!", "Para a história!", "Inesquecível!", "O melhor de todos!", "Sem comparação!", "Inigualável!", "Fora de série!", "Fenomenal!", "Que chupada!", "Até o bagaço!", "Lambeu os beiços!", "Deixou limpinho!", "Serviço completo!", "Não sobrou nada!", "Aspirou com vontade!", "Um profissional!", "Contratado!", "O funcionário do mês!", "Bateu o ponto!", "Meta atingida!", "Superou as expectativas!", "É disso que o povo gosta!", "A alegria da galera!", "Fez a festa!", "O rei do camarote!", "Brilhou!", "Estrela da noite!", "Protagonista!", "O homem do jogo!", "MVP da partida!"
        ];
        let temporaryPlayerEmoji = null;

        // --- LOCAL DATA & RANKING LOGIC ---
        function loadLocalData() {
            highScore = parseInt(localStorage.getItem('leiteMachoHighScore_v2') || '0', 10);
            totalMilk = parseInt(localStorage.getItem('leiteMachoTotalMilk_v2') || '0', 10);
            PLAYER_EMOJI = localStorage.getItem('leiteMachoPlayerEmoji_v2') || '😏';
            unlockedEmojis = JSON.parse(localStorage.getItem('leiteMachoUnlockedEmojis_v2') || '["😏"]');
            highestLevelUnlocked = parseInt(localStorage.getItem('leiteMachoHighestLevel_v2') || '1', 10);
            localScores = JSON.parse(localStorage.getItem('leiteMachoLocalScores_v2') || '[]');
            updateUIDisplays();
        }
        
        function saveLocalData() {
            localStorage.setItem('leiteMachoHighScore_v2', highScore);
            localStorage.setItem('leiteMachoTotalMilk_v2', totalMilk);
            localStorage.setItem('leiteMachoPlayerEmoji_v2', PLAYER_EMOJI);
            localStorage.setItem('leiteMachoUnlockedEmojis_v2', JSON.stringify(unlockedEmojis));
            localStorage.setItem('leiteMachoHighestLevel_v2', highestLevelUnlocked);
            localStorage.setItem('leiteMachoLocalScores_v2', JSON.stringify(localScores));
        }
        
        function updateUIDisplays() {
            highScoreDisplays.forEach(el => el.textContent = `Recorde Infinito: ${highScore}`);
            totalMilkDisplays.forEach(el => el.textContent = `Leite Total: ${totalMilk}`);
        }

        function addScoreToLocalLeaderboard(newScore, name) {
            localScores.push({ name: name, score: newScore });
            localScores.sort((a, b) => b.score - a.score);
            localScores = localScores.slice(0, 50); // Keep top 50
            if (newScore > highScore) {
                highScore = newScore;
            }
            saveLocalData();
            updateUIDisplays();
        }

        function displayLocalLeaderboard() {
            showScreen(rankingScreen);
            rankingList.innerHTML = '';
            if (localScores.length === 0) {
                rankingList.innerHTML = '<li class="loading">Nenhum recorde salvo ainda.</li>';
                return;
            }

            localScores.forEach((entry, index) => {
                const li = document.createElement('li');
                li.innerHTML = `<span class="rank">#${index + 1}</span><span class="name">${escapeHTML(entry.name || 'Anônimo')}</span><span class="score">${entry.score}</span>`;
                rankingList.appendChild(li);
            });
        }

        // --- GAME LOGIC ---
        function initGame(mode) {
            gameMode = mode;
            score = 0; lives = 3; gameOver = false;
            particles = []; items = [];
            isInvincible = false; invincibilityTimer = 0;
            isBossFightActive = false; bossState = {};
            milkSinceLastBoss = 0;
            combo = { count: 0, multiplier: 1 };
            slowedTimer = 0; goldenMilkTimer = 0; magnetTimer = 0;
            nextCelebrationScore = 50;
            
            if (gameMode === 'levels') { 
                levelGoal = LEVELS[currentLevel - 1].goal; 
                levelStars = 3; 
            } else { 
                levelGoal = -1; 
            }
            
            player = { x: canvas.width / 2 - PLAYER_SIZE / 2, y: canvas.height - PLAYER_SIZE - 20, width: PLAYER_SIZE, height: PLAYER_SIZE, bobble: 0, scaleX: 1, scaleY: 1 };
            if (!stars) createStars();

            updateUI();
            resetCombo();
            showScreen(null);
            uiContainer.classList.remove('hidden');
            bossHealthBar.classList.add('hidden');
            bossContainer.classList.remove('visible');
            nameInputContainer.classList.add('hidden');
            gameOverButtons.classList.remove('hidden');


            if (itemSpawnInterval) clearInterval(itemSpawnInterval);
            if(bossAttackInterval) clearInterval(bossAttackInterval);
            if(bossSpecialItemInterval) clearInterval(bossSpecialItemInterval);

            itemSpawnInterval = setInterval(spawnItem, 800);

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoop();
        }

        function gameLoop() {
            if (gameOver) return;

            const playerSpeed = 6;
            const currentSpeed = (slowedTimer > 0) ? playerSpeed / 2 : playerSpeed;
            let playerSpeedX = 0;
            if (keys['ArrowLeft'] || keys['a']) playerSpeedX = -currentSpeed;
            if (keys['ArrowRight'] || keys['d']) playerSpeedX = currentSpeed;
            if(playerSpeedX !== 0) {
                player.x += playerSpeedX;
                player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
                player.scaleX = 1.1; player.scaleY = 0.9;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(playerSpeedX);
            updateAndDrawParticles();
            drawPlayer();
            updateItems();
            drawItems();
            if(isBossFightActive) updateBoss();

            if (isInvincible && --invincibilityTimer <= 0) isInvincible = false;
            if (slowedTimer > 0) slowedTimer--;
            if (goldenMilkTimer > 0) goldenMilkTimer--;
            if (magnetTimer > 0) magnetTimer--;
            
            gameLoopId = requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            gameOver = true;
            cancelAnimationFrame(gameLoopId);
            clearInterval(itemSpawnInterval);
            if(isBossFightActive) { clearInterval(bossAttackInterval); clearInterval(bossSpecialItemInterval); }
            
            totalMilk += score;
            
            finalScoreElement.textContent = `Você fez ${score} pontos!`;
            const isNewHighScore = gameMode === 'infinite' && score > highScore;
            
            if (isNewHighScore) {
                nameInputContainer.classList.remove('hidden');
                gameOverButtons.classList.add('hidden');
            } else {
                nameInputContainer.classList.add('hidden');
                gameOverButtons.classList.remove('hidden');
            }
            
            saveLocalData();
            updateUIDisplays();
            
            const gameOverLevelButton = gameOverScreen.querySelector('.level-select-button');
            if (gameOverLevelButton) gameOverLevelButton.style.display = gameMode === 'levels' ? 'inline-block' : 'none';
            
            showScreen(gameOverScreen);
        }

        function levelComplete() {
            gameOver = true;
            cancelAnimationFrame(gameLoopId);
            clearInterval(itemSpawnInterval);
            totalMilk += score;
            unlockNextLevel();
            saveLocalData();
            
            const finalStarsElement = document.querySelector('#level-complete-screen .final-stars');
            const nextLevelButton = document.getElementById('next-level-button');
            if (finalStarsElement) finalStarsElement.innerHTML = '⭐'.repeat(levelStars) + '☆'.repeat(3 - levelStars);
            if (nextLevelButton) nextLevelButton.style.display = (currentLevel < LEVELS.length) ? 'inline-block' : 'none';
            
            showScreen(levelCompleteScreen);
        }

        function unlockNextLevel() {
            if (gameMode === 'levels' && currentLevel === highestLevelUnlocked && currentLevel < LEVELS.length) {
                highestLevelUnlocked++;
            }
        }

        function updateItems() {
            const speedMultiplier = 1 + Math.floor(score / 50) * 0.05;
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                if (item.type === 'projectile') { item.x += item.speedX; item.y += item.speedY; } 
                else if (item.type === 'hit-projectile') {
                    const bossYPos = bossContainer.offsetTop + bossContainer.offsetHeight / 2;
                    item.y -= 20;
                    if(item.y < bossYPos) {
                        createParticles(bossContainer.offsetLeft + bossContainer.offsetWidth / 2, bossYPos, 'red', 50);
                        bossState.health--;
                        bossContainer.classList.add('hit');
                        setTimeout(() => bossContainer.classList.remove('hit'), 200);
                        items.splice(i, 1);
                        continue;
                    }
                } else {
                    if (magnetTimer > 0 && (item.type === 'milk' || item.type === 'golden-milk')) {
                        const dx = (player.x + player.width / 2) - (item.x + ITEM_SIZE / 2);
                        item.x += dx * 0.05;
                    }
                    item.y += item.speed * speedMultiplier;
                }

                if (item.y + ITEM_SIZE > player.y && item.y < player.y + player.height && item.x + ITEM_SIZE > player.x && item.x < player.x + player.width) {
                    let collected = true;
                    switch(item.type) {
                        case 'milk':
                            const pointsToAdd = goldenMilkTimer > 0 ? 2 * combo.multiplier : 1 * combo.multiplier;
                            score += pointsToAdd;
                            if (gameMode === 'infinite' && !isBossFightActive) {
                                milkSinceLastBoss += pointsToAdd;
                            }
                            combo.count++;
                            if (combo.count >= 10) combo.multiplier = 3; else if (combo.count >= 5) combo.multiplier = 2;
                            comboDisplay.style.display = 'flex'; comboMultiplierSpan.textContent = `x${combo.multiplier}`;
                            triggerPlayerAnimation('collect');
                            if (milkSinceLastBoss >= 100 && !isBossFightActive && gameMode === 'infinite') { startBossFight(); } 
                            else if (score >= nextCelebrationScore && !isBossFightActive) { showCelebration(); nextCelebrationScore += 50; }
                            createParticles(item.x, item.y, 'white', 25);
                            if (gameMode === 'levels' && score >= levelGoal) { levelComplete(); return; }
                            break;
                        case 'obstacle': case 'projectile': case 'slow':
                            if (!isInvincible) {
                                lives--; resetCombo(); triggerPlayerAnimation('damage');
                                if (item.type === 'slow') slowedTimer = 300;
                                if (gameMode === 'levels') levelStars = Math.max(1, levelStars - 1);
                                createParticles(item.x, item.y, '#8e44ad', 35);
                                gameContainer.classList.add('shake'); setTimeout(() => gameContainer.classList.remove('shake'), 200);
                                if (lives <= 0) { endGame(); return; }
                            } else { createParticles(item.x, item.y, 'lightgray', 15); }
                            break;
                        case 'shield': isInvincible = true; invincibilityTimer = 300; score += 2; triggerPlayerAnimation('collect'); createParticles(item.x, item.y, 'gold', 40); break;
                        case 'heart': if (lives < 5) lives++; createParticles(item.x, item.y, 'pink', 30); break;
                        case 'golden-milk': goldenMilkTimer = 300; createParticles(item.x, item.y, 'gold', 50); break;
                        case 'magnet': magnetTimer = 300; createParticles(item.x, item.y, '#8e44ad', 40); break;
                        case 'glowing-milk': items.push({ x: player.x, y: player.y, type: 'hit-projectile' }); createParticles(item.x, item.y, 'cyan', 30); break;
                        default: collected = false; break;
                    }
                    if (collected) { items.splice(i, 1); updateUI(); continue; }
                }
                if (item.y > canvas.height) { if(item.type === 'milk') resetCombo(); items.splice(i, 1); }
            }
        }
        
        // --- GAME LOGIC HELPER FUNCTIONS ---
        function updateUI() { scoreElement.textContent = gameMode === 'levels' ? `${score} / ${levelGoal}` : score; livesElement.textContent = lives; }
        function triggerPlayerAnimation(type) { if (type === 'collect') { temporaryPlayerEmoji = '😋'; } else if (type === 'damage') { temporaryPlayerEmoji = '😵'; player.damageFlash = 10; uiContainer.querySelector('#lives').classList.add('pulsate'); setTimeout(() => uiContainer.querySelector('#lives').classList.remove('pulsate'), 500); } setTimeout(() => { temporaryPlayerEmoji = null; }, 300); }
        function resetCombo() { combo.count = 0; combo.multiplier = 1; comboDisplay.style.display = 'none'; }
        function showScreen(screen) { allScreens.forEach(s => s.classList.add('hidden')); if(screen) screen.classList.remove('hidden'); }
        function escapeHTML(str) { const div = document.createElement('div'); div.appendChild(document.createTextNode(str || "")); return div.innerHTML; }
        function createStars() { stars = Array.from({length: 200}, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.8, parallax: 0.1 + Math.random() * 0.9, color: `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})` })); }
        function drawStars(playerSpeedX) { stars.forEach(star => { star.x -= playerSpeedX * star.parallax * 0.1; if (star.x < 0) star.x = canvas.width; if (star.x > canvas.width) star.x = 0; star.y += star.parallax * 0.2; if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; } const flicker = Math.sin(Date.now() * 0.001 + star.x) * 0.2 + 0.8; ctx.fillStyle = star.color.replace(/[\d\.]+\)$/g, `${flicker})`); ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill(); }); }
        function createParticles(x, y, color, count) { for (let i = 0; i < count; i++) { particles.push({ x, y, color, size: Math.random() * 6 + 2, speedX: (Math.random() - 0.5) * 8, speedY: (Math.random() - 0.5) * 8, life: 50 }); } }
        function updateAndDrawParticles() { for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.speedX; p.y += p.speedY; p.speedY += 0.1; p.speedX *= 0.98; p.life--; if (p.life <= 0) { particles.splice(i, 1); } else { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 50; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); } } ctx.globalAlpha = 1.0; }
        function drawPlayer() { if (!player) return; player.bobble += 0.1; const yOffset = Math.sin(player.bobble) * 3; ctx.save(); ctx.translate(player.x + player.width / 2, player.y + player.height / 2 + yOffset); ctx.scale(player.scaleX, player.scaleY); ctx.shadowOffsetY = 8; ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowBlur = 15; if (isInvincible) { ctx.shadowColor = "gold"; ctx.shadowBlur = 25; } else if (player.damageFlash > 0) { ctx.shadowColor = "red"; ctx.shadowBlur = 25; player.damageFlash--; } else if (slowedTimer > 0) { ctx.shadowColor = "cyan"; ctx.shadowBlur = 20; } ctx.font = `${PLAYER_SIZE}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(temporaryPlayerEmoji || PLAYER_EMOJI, 0, 0); ctx.restore(); player.scaleX += (1 - player.scaleX) * 0.2; player.scaleY += (1 - player.scaleY) * 0.2; }
        function drawItems() { ctx.font = `${ITEM_SIZE}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; for (const item of items) { let emoji; switch(item.type) { case 'milk': emoji = MILK_EMOJI; break; case 'obstacle': emoji = OBSTACLE_EMOJI; break; case 'projectile': emoji = bossState.projectile; break; case 'heart': emoji = HEART_EMOJI; break; case 'slow': emoji = SLOW_EMOJI; break; case 'magnet': emoji = MAGNET_EMOJI; break; case 'golden-milk': emoji = GOLDEN_MILK_EMOJI; break; case 'glowing-milk': emoji = GLOWING_MILK_EMOJI; break; case 'shield': emoji = SHIELD_EMOJI; break; case 'hit-projectile': emoji = MILK_EMOJI; break; default: emoji = '❓'; break; } if (item.rotation !== undefined) item.rotation += item.rotationSpeed; const pulse = (item.type === 'glowing-milk' || item.type === 'golden-milk' || item.type === 'shield' || item.type === 'heart') ? 1.2 + Math.sin(Date.now()*0.01)*0.2 : 1; ctx.save(); ctx.translate(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2); if (pulse !== 1) { ctx.shadowColor = item.type === 'heart' ? 'pink' : 'gold'; ctx.shadowBlur = 20; } if (item.rotation !== undefined) ctx.rotate(item.rotation); ctx.scale(pulse, pulse); ctx.fillText(emoji, 0, 0); ctx.restore(); } }
        function spawnItem(typeOverride = null) { if (gameOver) return; const x = Math.random() * (canvas.width - ITEM_SIZE); let type, speed = 2.5 + Math.random() * 3.5; if (typeOverride) { type = typeOverride; if(type === 'projectile'){ bossContainer.classList.add('throw'); setTimeout(() => bossContainer.classList.remove('throw'), 300); const bossX = bossContainer.offsetLeft + bossContainer.offsetWidth / 2; const bossY = bossContainer.offsetTop + bossContainer.offsetHeight / 2; const angle = Math.atan2((player.y + player.height / 2) - bossY, (player.x + player.width / 2) - bossX); const projSpeed = 5 + Math.random() * 2; items.push({ x: bossX, y: bossY, speedX: Math.cos(angle) * projSpeed, speedY: Math.sin(angle) * projSpeed, type: 'projectile'}); return; } } else { const rand = Math.random(); if (rand < 0.02) { type = 'golden-milk'; } else if (rand < 0.05) { type = 'magnet'; } else if (rand < 0.08) { type = 'shield'; } else if (rand < 0.12 && lives < 5) { type = 'heart'; } else if (rand < 0.70) { type = 'milk'; } else if (rand < 0.85) { type = 'slow'; } else { type = 'obstacle'; } } items.push({ x, y: -ITEM_SIZE, speed, type, rotation: Math.random() * Math.PI, rotationSpeed: (Math.random() - 0.5) * 0.1 }); }
        function startBossFight() { isBossFightActive = true; milkSinceLastBoss = 0; const currentBossIndex = Math.floor(Math.random() * BOSSES.length); const currentBoss = BOSSES[currentBossIndex]; bossArrivalText.textContent = `O ${currentBoss.name} CHEGOU!`; bossContainer.textContent = currentBoss.emoji; bossArrivalText.classList.add('animate'); setTimeout(() => bossArrivalText.classList.remove('animate'), 2000); clearInterval(itemSpawnInterval); bossState = { health: 10, maxHealth: 10, ...currentBoss }; bossContainer.classList.add('visible'); bossHealthBar.classList.remove('hidden'); bossHealthBar.classList.add('visible'); updateBoss(); bossAttackInterval = setInterval(() => { if(!gameOver) spawnItem('projectile'); }, 1500); bossSpecialItemInterval = setInterval(() => { if(!gameOver) spawnItem('glowing-milk'); }, 4000); }
        function updateBoss() { bossHealthFill.style.width = `${(bossState.health / bossState.maxHealth) * 100}%`; if(bossState.health <= 0) endBossFight(); }
        function endBossFight() { if (!isBossFightActive) return; isBossFightActive = false; const bossRect = bossContainer.getBoundingClientRect(); createParticles(bossRect.left + bossRect.width/2, bossRect.top + bossRect.height/2, 'gold', 200); bossContainer.classList.remove('visible'); bossHealthBar.classList.add('hidden'); clearInterval(bossAttackInterval); clearInterval(bossSpecialItemInterval); itemSpawnInterval = setInterval(spawnItem, 800); score += 250; milkSinceLastBoss = 0; updateUI(); }
        function showCelebration() { const message = CELEBRATION_MESSAGES[Math.floor(Math.random() * CELEBRATION_MESSAGES.length)]; celebrationText.textContent = message; celebrationText.classList.add('animate'); setTimeout(() => celebrationText.classList.remove('animate'), 2000); }
        function populateLevelSelect() { levelSelectContainer.innerHTML = ''; LEVELS.forEach((level, index) => { const levelNum = index + 1; const button = document.createElement('button'); button.textContent = levelNum; if (levelNum > highestLevelUnlocked) { button.disabled = true; button.innerHTML = `🔒<span style="font-size: 0.7em; display: block;">${level.goal}🥛</span>`; } else { button.addEventListener('click', () => { currentLevel = levelNum; initGame('levels'); }); } levelSelectContainer.appendChild(button); }); }
        function populateEmojiSelect() { emojiSelectContainer.innerHTML = ''; PLAYER_EMOJIS.forEach(emoji => { const isUnlocked = unlockedEmojis.includes(emoji); const price = EMOJI_PRICES[emoji]; const itemDiv = document.createElement('div'); itemDiv.className = 'emoji-item'; const button = document.createElement('button'); button.className = 'emoji-button'; button.textContent = emoji; if (emoji === PLAYER_EMOJI) button.classList.add('selected'); button.addEventListener('click', () => { if (isUnlocked) { PLAYER_EMOJI = emoji; saveLocalData(); populateEmojiSelect(); } else if (totalMilk >= price) { buyEmoji(emoji, price); } }); const priceDiv = document.createElement('div'); priceDiv.className = 'price'; if (isUnlocked) { priceDiv.textContent = '✔️'; priceDiv.classList.add('unlocked'); } else { priceDiv.innerHTML = `🥛 <span>${price}</span>`; if (totalMilk < price) { button.disabled = true; } } itemDiv.appendChild(button); itemDiv.appendChild(priceDiv); emojiSelectContainer.appendChild(itemDiv); }); }
        function buyEmoji(emoji, price) { if (totalMilk >= price) { totalMilk -= price; unlockedEmojis.push(emoji); PLAYER_EMOJI = emoji; saveLocalData(); updateUIDisplays(); populateEmojiSelect(); } }

        // --- ENTRY POINT & EVENT LISTENERS ---
        function setupEventListeners() {
            window.addEventListener('keydown', (e) => keys[e.key] = true);
            window.addEventListener('keyup', (e) => keys[e.key] = false);
            function movePlayer(clientX) { if (!player || gameOver) return; const rect = canvas.getBoundingClientRect(); player.x = clientX - rect.left - player.width / 2; player.x = Math.max(0, Math.min(player.x, canvas.width - player.width)); player.scaleX = 1.1; player.scaleY = 0.9; }
            canvas.addEventListener('mousemove', (e) => movePlayer(e.clientX));
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (e.touches[0]) movePlayer(e.touches[0].clientX); }, { passive: false });

            document.querySelector('button[data-mode="infinite"]').addEventListener('click', () => initGame('infinite'));
            document.querySelector('button[data-mode="levels"]').addEventListener('click', () => { populateLevelSelect(); showScreen(levelSelectScreen); });
            document.getElementById('ranking-button').addEventListener('click', displayLocalLeaderboard);
            document.getElementById('choose-emoji-button').addEventListener('click', () => { populateEmojiSelect(); showScreen(emojiSelectScreen); });
            document.getElementById('restart-button').addEventListener('click', () => initGame(gameMode));
            
            document.getElementById('save-score-button').addEventListener('click', () => {
                const nameInput = document.getElementById('player-name-input');
                const name = nameInput.value.trim() || 'Anônimo';
                addScoreToLocalLeaderboard(score, name);
                nameInputContainer.classList.add('hidden');
                gameOverButtons.classList.remove('hidden');
            });
            
            document.querySelectorAll('.back-to-menu-button').forEach(btn => btn.addEventListener('click', () => showScreen(mainMenu)));
            document.querySelectorAll('.level-select-button').forEach(btn => btn.addEventListener('click', () => { populateLevelSelect(); showScreen(levelSelectScreen); }));
            
            const nextLevelButton = document.getElementById('next-level-button');
            if (nextLevelButton) nextLevelButton.addEventListener('click', () => { if (currentLevel < LEVELS.length) { currentLevel++; initGame('levels'); } });
            
            window.addEventListener('resize', () => { canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; if (stars) createStars(); });
        }

        function main() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            setupEventListeners();
            loadLocalData();
            showScreen(mainMenu);
        }

        main();
    </script>
</body>
</html>
�
